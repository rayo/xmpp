<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc strict="yes"?>
<rfc category="std" docName="draft-meyer-xmpp-e2e-encryption-00" ipr="trust200811">
  
  <front>
    <title abbrev='XTLS'>Extensible Messaging and Presence Protocol (XMPP) End-to-End Encryption Using Transport Layer Security ("XTLS")</title>
    <author initials="D." surname="Meyer" fullname="D.  Meyer">
      <organization>TZI, Universitaet Bremen</organization>
      <address>
	<email>dmeyer@tzi.de</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="P.  Saint-Andre">
      <organization>Cisco</organization>
      <address>
	<email>psaintan@cisco.com</email>
      </address>
    </author>
    <date year="2009" month="February" day="24"/>
    <area>Applications</area>
    <keyword>Extensible Messaging and Presence Protocol</keyword>
    <keyword>XMPP</keyword>
    <keyword>Jabber</keyword>
    <keyword>encryption</keyword>
    <abstract>
      <t>This document specifies "XTLS", a protocol for end-to-end encryption of Extensible Messaging and Presence Protocol (XMPP) traffic via an application-level usage of Transport Layer Security (TLS).  XTLS treats the end-to-end exchange of XML stanzas as a virtual transport and uses TLS to secure that transport, thus enabling XMPP entities to communicate in a way that is designed to prevent eavesdropping, tampering, and forgery of XML stanzas.  The protocol can be used for secure end-to-end messaging as well as any others application such as file transfer.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" anchor="intro">
      <t>End-to-end encryption of traffic sent over the Extensible Messaging and Presence Protocol (XMPP) is a desirable goal.  Since 1999, the Jabber/XMPP developer community has experimented with several such technologies, including OpenPGP <xref target='XEP-0027'/>, S/MIME (<xref target='RFC3923'/>, and encrypted sessions or "ESessions" (<xref target='XEP-0218'/>.  For various reasons, these technologies have not been widely implemented and deployed.  When the XMPP Standards Foundation asked various Internet security experts to complete a security review of encrypted sessions, it was recommended to explore the possibility of instead using the Transport Layer Security <xref target='TLS'/> as the base technology for XMPP.  That possibility is explored in this document.</t>
      <t>TLS is the most widely implemented protocol for securing network traffic.  In addition to applications in the email infrastructure, the World Wide Web <xref target='HTTP-TLS'/>, and datagram transport for multimedia session negotiation <xref target='DTLS'/>, TLS is used in XMPP to secure TCP connections from client to server and from server to server, as specified in <xref target='RFC3920'/> and <xref target='rfc3920bis'/>.  Therefore TLS is already familiar to XMPP developers.</t>
      <t>This specification, called "XTLS", defines a method whereby any XMPP entity that supports the XMPP Jingle negotiation framework <xref target='XEP-0166'/> can use TLS semantics for end-to-end encryption, whether the application data is sent over a streaming transport (like TCP) or a datagram transport (like UDP).  The basic use case is to tunnel XMPP stanzas between two IM users for end-to-end secure chat using end-to-end XML streams as defined in <xref target='XEP-0247'/>.  However, XTLS is not limited to encryption of one-to-one text chat, since it can be used between two XMPP clients for encryption of any XMPP payloads, between an XMPP client and a remote XMPP service (i.e., a service with which a client does not have a direct XML stream, such as a <xref target='XEP-0045'/> chatroom), or between two remote XMPP services.  Furthermore, XTLS can be used for encrypted file transfer (see <xref target='XEP-0234'/>, for encrypted voice or video sessions using <xref target='XEP-0167'/> and <xref target='DTLS-SRTP'/>, and other applications.</t>
    </section>

    <section title='Requirements' anchor='req'>
      <t>This specification is intended to meet the requirements defined in <xref target='XEP-0210'/> using building blocks that are already widely supported in XMPP clients, such as TLS, XML streams, Jingle, and in-band bytestreams <xref target='XEP-0047'/>.  It is possible that some of those requirements can be met only with particular TLS cipher suites, or cannot be met at all without defining extensions to TLS itself.  A full gap analysis has not yet been completed.</t>
    </section>

    <section title='Approach' anchor='approach'>
      <t>In broad outline, XTLS takes the following approach to end-to-end encryption of XMPP traffic:</t>
      <t>
        <list style='numbers'>
          <t>We assume that all XMPP entities will have X.509 certificates, typically self-signed and automatically generated by an XMPP client (although CA-issued certificates are acceptable).</t>
          <t>We use the XMPP Jingle extensions as the negotiation framework.</t>
          <t>We define a &lt;security/&gt; element that can be included in any Jingle negotiation, and a new "security-info" Jingle action for sending security-related information.</t>
          <t>When an entity wishes to encrypt its communications with a second entity, it sends a Jingle session-initiate request that specifies the desired application type (e.g., file transfer), a possible transport (e.g., SOCKS5 bytestreams), and security information such as the sender's X.509 fingerprint and supported TLS methods (e.g., secure remote password).</t>
          <t>If both parties support XTLS, the first data sent over the negotiated transport is TLS handshake data, not application data.  Once the TLS handshake has finished, the parties can then send application data over the now-encrypted transport.</t>
          <t>The simplest scenario is end-to-end encryption of traditional XMPP text chat using end-to-end XML streams, in-band bytestreams, and previously-accepted X.509 certificates.</t>
          <t>On first use of end-to-end encryption between two entities, it is encouraged to use secure remote passwords rather than leap-of-faith to bootstrap the subsequent use of the client-generated X.509 certificates.</t>
          <t>More complex scenarios are theoretically supported (e.g., encrypted file transfer using SOCKS5 bytestreams and encrypted voice chat using DTLS-SRTP) but have not yet been fully defined.</t>
          <t>XTLS theoretically can be used to establish a TLS-encrypted streaming transport or a DTLS-encrypted datagram transport, but integration with DTLS (<xref target='DTLS'/> has not yet been prototyped so use with streaming transports is the more stable scenario.</t>
        </list>
      </t>
      <t>We expand on this approach in the following section.</t>
    </section>

    <section title='Basic Protocol' anchor='proto'>
      <t>The basic flow for an XTLS session is as follows, where traffic represented by single dashes (---) is sent over the XMPP signalling channel and traffic represented by double lines (===) is sent over the negotiated transport.</t>
      <figure>
        <artwork><![CDATA[
Initiator                   Responder
  |                            |
  |  session-initiate          |
  |  (with security info)      |
  |--------------------------->|
  |  ack                       |
  |<---------------------------|
  |  session-accept            |
  |<---------------------------|
  |  ack                       |
  |--------------------------->|
  |  open transport            |
  |<==========================>|
  |  TLS ClientHello           |
  |===========================>|
  |  TLS ServerHello, [...]    |
  |<===========================|
  |  TLS [...], Finished       |
  |===========================>|
  |  TLS [...], Finished       |
  |<===========================|
  |  application data          |
  |<==========================>|
  |  session-terminate         |
  |<---------------------------|
  |  ack                       |
  |--------------------------->|
  |                            |
        ]]></artwork>
      </figure>
      <t>To simplify the description we assume here that the parties already trust each other's certificates.  See the next section for information about bootstrapping of certificate trust on the first communication.</t>
      <t>First the initiator sends a Jingle session-initiate request (here the simple case of an end-to-end text chat session using the <xref target='XEP-0261'/>.  This request includes a &lt;security/&gt; element that contains the fingerprint of the certificate that the initiator will use during the TLS negotiation.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='xn28s7gk'
    to='juliet@capulet.lit/balcony'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:0'>
          action='session-initiate'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <content creator='initiator' name='xmlstream'>
      <description xmlns='urn:xmpp:jingle:apps:xmlstream:0'/>
      <transport xmlns='urn:xmpp:jingle:transports:ibb:0'
                 block-size='4096'
                 sid='ch3d9s71'/>
      <security xmlns='urn:xmpp:jingle:security:xtls:0'>
        <fingerprint>RomeoX509CertificateHash</fingerprint>
        <method name='x509'/>
        <method name='srp'/>
      </security>
    </content>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder immediately acknowledges receipt of the session-initiate.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='xn28s7gk'
    to='romeo@montague.net/orchard'
    type='result'/>
        ]]></artwork>
      </figure>
      <t>Depending on the application type, a user agent controlled by a human user might need to wait for the user to affirm a desire to proceed with the session before continuing.  When the user agent has received such affirmation (or if the user agent can automatically proceed for any reason, e.g.  because no human intervention is expected or because a human user has configured the user agent to automatically accept sessions with a given entity), it returns a Jingle session-accept message.  This message will typically contain the offered application type, transport method, and a &lt;security/&gt; element that includes the fingerprint of the responder's X.509 certificate as well as the responder's supported TLS methods.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='hf64hl'
    to='romeo@montague.net/orchard'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:0'>
          action='session-accept'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <content creator='initiator' name='xmlstream'>
      <description xmlns='urn:xmpp:jingle:apps:xmlstream:0'/>
      <transport xmlns='urn:xmpp:jingle:transports:ibb:0'
                 block-size='4096'
                 sid='ch3d9s71'/>
      <security xmlns='urn:xmpp:jingle:security:xtls:0'/>
        <fingerprint>JulietX509CertificateHash</fingerprint>
        <method name='x509'/>
        <method name='srp'/>
      </security>
    </content>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The following rules apply to the responder's handling of the session-initiate message:</t>
      <t>
        <list style='numbers'>
          <t>If the responder does not support Jingle-XTLS it will silently ignore the &lt;security/&gt; element in the offer and therefore will return a session-accept message without a &lt;security/&gt; element.</t>
          <t>If the responder supports Jingle-XTLS it SHOULD return a session-accept message that contains a &lt;security/&gt; element.</t>
          <t>If the responder thinks it will be able to verify the initiator's certificate, it MUST include the fingerprint for the responder's certificate in the &lt;security/&gt; element of the session-accept message.  This is the "happy path" and will occur when the parties have already verified each other's certificates.</t>
          <t>If the responder thinks it will not be able to verify the initiator's certificate, it MAY omit the fingerprint for the responder's certificate in the &lt;security/&gt; element of the session-accept message.  This indicates that certificate-based authentication is not possible.  In this case the responder SHOULD signal that it wishes to use some other authentication method, such as secure remote passwords (see the next section).</t>
          <t>If the responding client cannot verify the initiator's certificate, it SHOULD ask the responding user if a password was exchanged between the parties that can be used for TLS-SRP.  If this is not the case, setting up a mutually-authenticated link will fail and the responder MAY terminate the session.  Alternatively it could send its own fingerprint knowing it cannot authenticate the initiator, in which case the responder has to trust that there is no man-in-the-middle (see next section).</t>
        </list>
      </t>
      <t>When the responder sends the session-accept message, the initiator acknowledges receipt.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.net/orchard'
    id='hf64hl'
    to='juliet@capulet.com/balcony'
    type='result'/>
        ]]></artwork>
      </figure>
      <t>The following rules apply to the initiator's handling of the session-accept message:</t>
      <t>
        <list style='numbers'>
          <t>If the initiator receives a session-accept without a &lt;security/&gt; element, setting up a secure transport layer has failed.  The initiator MAY terminate the session at this point or instead proceed without securing the transport.  The client SHOULD ask the initiating user how to processed.  This depends on the Jingle application and the initiator's preferences: it makes no sense to use end-to-end XML streams without encryption, but the initiator might continue a file transfer without encryption.</t>
          <t>If the initiating client cannot verify the responder's certificate it SHOULD ask the initiating user if a password was exchanged between the parties that can be used for TLS-SRP.  If this is not the case, setting up a mutually-authenticated link will fail and the responder MAY terminate the session or proceed with leap-of-faith (see next section).</t>
        </list>
      </t>
      <t>The initiator can now determine if X.509 certificate based authentication will work or if TLS-SRP will be used.  It sends an additional security-info message to the responder to signal its choice.  This step is not really necessary because the responder will see the initiator's choice in the first message of the TLS handshake, but it can help an implementation to set up its TLS library properly.  Because in this section we assume that the parties already have validated each other's certificates, the security method signalled here is "x509".</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='hf749j'
    to='juliet@capulet.lit/balcony'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:0'>
          action='security-info'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <content creator='initiator' name='xmlstream'>
      <security xmlns='urn:xmpp:jingle:security:xtls:0'>
        <method name='x509'/>
      </security>
    </content>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The responder acknowledges receipt.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.lit/balcony'
    id='hf749j'
    to='romeo@montague.lit/orchard'
    type='result'/>
        ]]></artwork>
      </figure>
      <t>Parallel to the security-info exchange the clients set up a transport for the Jingle session.  This example uses <xref target='XEP-0261'/> which does not require any additional messages (other transport like <xref target='XEP-0260'/> and <xref target='XEP-0176'/> need more time to set up).  Each transport MUST define a specific time when both cients know that the transport is ready.  When XTLS is not used, the Jingle implementation would signal to the using application that the transport is open when the session-accept is sent or received, or when connectivity checks determine media can flow over one of the transport candidates.  When XTLS is used, the Jingle implementation starts a TLS handshake on the transport and signals to the using application that the transport is open only after the four-way TLS handshake is finished successfully.</t>
      <t>During the TLS handshake, the responder MUST take the role of the TLS server and the initiator MUST take the role of the TLS client.  During the handshake, the responder (acting as the TLS server) MUST send a CertificateRequest.</t>
      <t>If either client cannot verify the certificate of the peer or receives an invalid message on the TLS layer, it shall terminate the Jingle session immediately, including a Jingle reason of &lt;security-error/&gt;.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='hz81vf48'
    to='juliet@capulet.lit/balcony'
    type='set'>
  <jingle xmlns='urn:xmpp:jingle:0'
          action='session-terminate'
          initiator='romeo@montague.lit/orchard'
          sid='a73sjjvkla37jfea'>
    <reason><security-error/></reason>
  </jingle>
</iq>
        ]]></artwork>
      </figure>
      <t>The other party then acknowledges the session-terminate and the Jingle session is finished.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.lit/balcony'
    id='hz81vf48'
    to='romeo@montague.lit/orchard'
    type='result'/>
        ]]></artwork>
      </figure>
      <t>If the TLS negotiation succeeds, then the Jingle implementation shall signal to the using application that the transport is open.  The parties can then exchange application data over the encrypted transport.</t>
    </section>

<section title='Bootstrapping Trust on First Communication' anchor='bootstrapping'>
  <t>When two parties first attempt to use XTLS, their certificates might not be accepted (e.g., because they are self-signed or issued by unknown certification authorities).  Therefore each party needs to accept the other's certificate for use in future communication sessions.  There are several ways to do so:</t>
  <t>
    <list style='symbols'>
      <t>Leap of faith.  The recipient can hope that there is no man-in-the-middle during the first communication session.  If the certificate does not change in future sessions, the recipient at least knows that it is talking with the same entity it talked with during the first session.  However, that entity might be a man-in-the-middle rather than the assumed communication partner.  Therefore, leap of faith is discouraged.</t>
      <t>Check fingerprints.  The parties could validate the certificate fingerprints via some trusted means outside the XMPP band, such as in person, via encrypted email, or over the phone.  This is not user-friendly because certificate fingerprints consist of long strings of letters and numbers.  As a result, few humans check certificate fingerprints in protocols such as Secure Shell.</t>
      <t>One-time password.  The parties can exchange a user-friendly password known only to themselves and verify it out of band before the TLS handshake finishes.  For this purpose, it is REQUIRED for implementations to support at least one TLS cipher that uses Secure Remote Password (SRP) as defined in <xref target='SRP'/>.</t>
      <t>Channel binding.  It is possible that a future version will describe how to use an appropriate Simple Authentication and Security Layer (SASL) mechanism, such as &scram;, to authenticate the XTLS channel after the TLS handshake finishes using the concept of channel bindings (see <xref target='RFC5056'/>.</t>
    </list>
  </t>
  <t>If the parties use a password or channel binding via SASL, the process needs to be completed only once.  After the clients have authenticated with the shared secret, they can exchange their certificates for future communication.</t>
  <section title='Exchanging Certificates' anchor='exchange'>
    <t>To retrieve the certificate of the peer for future communications, a client SHOULD request the certificate according to <xref target='XEP-0189'/> over the secure connection.  This only works if XTLS was used to set up an end-to-end secure XML stream defined in <xref target='XEP-0247'/>; exchanging certificates if XTLS was used for other purposes like file transfer is not possible.  A client MUST NOT request the certificate over the insecure stream based on the connection to the XMPP server.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='hf7634k'
    to='juliet@capulet.lit/balcony'
    type='get'>
  <pubkeys xmlns='urn:xmpp:tmp:pubkey'/>
</iq>
        ]]></artwork>
      </figure>
    <t>The peer MUST return its own client certificate.  If the user has different clients with different client certificates and one user certificate, the user certificate SHOULD also be returned.  The user certificate allows it to verify other client certificates using public key retrieval described in <xref target='XEP-0189'/>.</t>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.com/balcony'
    id='hf7634k'
    to='romeo@montague.lit/orchard'
    type='result'>
  <pubkeys xmlns='urn:xmpp:tmp:pubkey'>
    <keyinfo>
      <name>JulietX509CertificateHash</name>
      <x509cert>
MIICCTCCAXKgAwIBAgIJALhU0Id6xxwQMA0GCSqGSIb3DQEBBQUAMA4xDDAKBgNV
BAMTA2ZvbzAeFw0wNzEyMjgyMDA1MTRaFw0wODEyMjcyMDA1MTRaMA4xDDAKBgNV
BAMTA2ZvbzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA0DPcfeJzKWLGE22p
RMINLKr+CxqozF14DqkXkLUwGzTqYRi49yK6aebZ9ssFspTTjqa2uNpw1U32748t
qU6bpACWHbcC+eZ/hm5KymXBhL3Vjfb/dW0xrtxjI9JRFgrgWAyxndlNZUpN2s3D
hKDfVgpPSx/Zp8d/ubbARxqZZZkCAwEAAaNvMG0wHQYDVR0OBBYEFJWwFqmSRGcx
YXmQfdF+XBWkeML4MD4GA1UdIwQ3MDWAFJWwFqmSRGcxYXmQfdF+XBWkeML4oRKk
EDAOMQwwCgYDVQQDEwNmb2+CCQC4VNCHesccEDAMBgNVHRMEBTADAQH/MA0GCSqG
SIb3DQEBBQUAA4GBAIhlUeGZ0d0msNVxYWAXg2lRsJt9INHJQTCJMmoUeTtaRjyp
ffJtuopguNNBDn+MjrEp2/+zLNMahDYLXaTVmBf6zvY0hzB9Ih0kNTh23Fb5j+yK
QChPXQUo0EGCaODWhfhKRNdseUozfNWOz9iTgMGw8eYNLllQRL//iAOfOr/8
      </x509cert>
    </keyinfo>
  </pubkeys>
</iq>
        ]]></artwork>
      </figure>
  </section>
  <section title='Verification of Non-Human Parties' anchor='bootstrap-bot'>
    <t>If one of the parties is a "bot" (e.g., an automated service or a device such as a set-top box), the password exchange is a bit more complicated.  It is similar to Bluetooth peering if the user has access to both clients at the same time.  One of the following scenarios might apply:</t>
    <t>
      <list style='symbols'>
        <t>The bot can be controlled via a remote control input device.  The human user can enter the same password or "PIN" on both the bot and the XMPP client.</t>
        <t>If the bot has no user input but does have a small display, it could display a random password.  The human user can then enter the provided password on the XMPP client.</t>
        <t>The bot might have not enough buttons for input and has no output device.  In that case the password is fixed.  Similar to Bluetooth peering with simple devices such as a headset, the password will be written in the manual or printed on the device.  For security reasons the device SHOULD NOT use password-based authentication without any user input.  Many Bluetooth devices have at least one button to set the device into peering mode.</t>
        <t>A bot may be associated with a web service and could display a random password when the user has logged in to the web site using HTTPS.  This assumes that an attacker does not have control over the web server and can perform a man-in-the-middle attack on XMPP level at the same time.  If the web service knows the GPG-key of the user (e.g.  launchpad) it could send an encrypted email.</t>
      </list>
    </t>
    <t>A user might have different X.509 certificates for each device.  <xref target='XEP-0189'/> can be used to manage the user's certificates.  A client SHOULD check the peer's PubSub node for certificates.  This makes it possible to use the password method only once between two users even if one or both users switch clients.  This makes it also possible for a user to communicate with a friend's bots.  They first open a secure link between two chat clients with a password and exchange the user certificates.  After that each user can verify all devices of the other without the need of a password.</t>
    <t>The retrieved certificate from the PubSub node may be signed by a CA the client can verify.  In that case the client MAY skip the password authentication and rely on the X.509 certificate chain.  The client SHOULD ask the user if the certificate should be accepted or if a password exchange is desired.</t>
  </section>
</section>

    <section title='Determining Support' anchor='support'>
      <t>If an entity wishes to request the use of XTLS, it SHOULD first determine whether the intended responder supports the protocol.  This can be done directly via <xref target='XEP-0030'/> or indirectly via <xref target='XEP-0115'/>.</t>
      <t>If an entity supports XTLS, it MUST report that by including a service discovery feature of "urn:xmpp:jingle:security:xtls:0" in response to disco#info requests.</t>
      <figure>
        <artwork><![CDATA[
<iq from='romeo@montague.lit/orchard'
    id='disco1'
    to='juliet@capulet.lit/chamber'
    type='get'>
  <query xmlns='http://jabber.org/protocol/disco#info'/>
</iq>
        ]]></artwork>
      </figure>
      <figure>
        <artwork><![CDATA[
<iq from='juliet@capulet.lit/chamber'
    id='disco1'
    to='romeo@montague.lit/orchard'
    type='result'>
  <query xmlns='http://jabber.org/protocol/disco#info'>
    <feature var='urn:xmpp:jingle:security:xtls:0'/>
  </query>
</iq>
        ]]></artwork>
      </figure>
      <t>Both service discovery and entity capabilities information could be corrupted or intercepted; for details, see under <xref target='security-dos'/>.</t>
    </section>

    <section title='Security Considerations' anchor='security'>
      <t>This entire document addresses security.  Particular security-related issues are discussed in the following sections.</t>
      <section title='Mandatory-to-Implement Technologies' anchor='security-mti'>
        <t>An implementation MUST at a minimum support the "srp" and "x509" methods.  A future version of this specification will document mandatory-to-implement TLS ciphers.</t>
      </section>
      <section title='Certificates' anchor='security-certs'>
        <t>As noted, XTLS can be used between XMPP clients, between an XMPP client and a remote XMPP service (i.e., a service with which a client does not have a direct XML stream), or between remote XMPP services.  Therefore, a party to an XTLS bytestream will present either a client certificate or a server certificate as appropriate.  Such certificates MUST be generated and validated in accordance with the certificate guidelines guidelines provided in <xref target='rfc3920bis'/>.</t>
        <t>A future version of this specification might provide additional guidelines regarding certificate validation in the context of client-to-client encryption.</t>
      </section>
      <section title='Denial of Service' anchor='security-dos'>
        <t>Currently XMPP stanzas such as Jingle negotiation messages and service discovery exchanges are not encrypted or signed. As a result, it is possible for an attacker to intercept these stanzas and modify them, thus convincing one party that the other party does not support XTLS and therefore denying the parties an opportunity to use XTLS.</t>
        <t>This is a more general problem with XMPP technologies and needs to be addressed at the core XMPP layer.</t>
      </section>
    </section>

    <section title='IANA Considerations' anchor='iana'>
    <t>It might be helpful to create a registry of TLS methods that can be used in the context of XTLS (e.g., "openpgp" for use of <xref target='RFC5081'/>, "srp" for use of <xref target='SRP'/>, and "x509" for use of <xref target='TLS'/> with certificates). The registry could be maintained by the IANA or by the XMPP Registrar. A future version of this specification will provide more detailed information about the registration requirements.</t>
    </section>

  </middle>

  <back>

    <references title="Normative References">

<reference anchor='RFC3920'>
<front>
<title abbrev='XMPP Core'>Extensible Messaging and Presence Protocol (XMPP): Core</title>
<author initials='P.' surname='Saint-Andre' fullname='Peter Saint-Andre' role='editor'>
<organization>Jabber Software Foundation</organization>
<address>
<email>stpeter@jabber.org</email></address></author>
<date year='2004' month='October' />
<area>Applications</area>
<workgroup>XMPP Working Group</workgroup>
<keyword>RFC</keyword>
<keyword>Request for Comments</keyword>
<keyword>I-D</keyword>
<keyword>Internet-Draft</keyword>
<keyword>XMPP</keyword>
<keyword>Extensible Messaging and Presence Protocol</keyword>
<keyword>Jabber</keyword>
<keyword>IM</keyword>
<keyword>Instant Messaging</keyword>
<keyword>Presence</keyword>
<keyword>XML</keyword>
<keyword>Extensible Markup Language</keyword>
<abstract>
<t>This memo defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a protocol for streaming Extensible Markup Language (XML) elements in order to exchange structured information in close to real time between any two network endpoints.  While XMPP provides a generalized, extensible framework for exchanging XML data, it is used mainly for the purpose of building instant messaging and presence applications that meet the requirements of RFC 2779.</t></abstract></front>
<seriesInfo name='RFC' value='3920' />
<format type='TXT' octets='194313' target='ftp://ftp.isi.edu/in-notes/rfc3920.txt' />
<format type='HTML' octets='237435' target='http://xml.resource.org/public/rfc/html/rfc3920.html' />
<format type='XML' octets='234474' target='http://xml.resource.org/public/rfc/xml/rfc3920.xml' />
</reference>

<reference anchor='rfc3920bis'>
<front>
<title>Extensible Messaging and Presence Protocol (XMPP): Core</title>
<author initials='P' surname='Saint-Andre' fullname='Peter Saint-Andre'>
    <organization />
</author>
<date month='October' day='16' year='2008' />
<abstract><t>This document defines the core features of the Extensible Messaging and Presence Protocol (XMPP), a technology for streaming Extensible Markup Language (XML) elements for the purpose of exchanging structured information in close to real time between any two or more network-aware entities.  XMPP provides a generalized, extensible framework for incrementally exchanging XML data, upon which a variety of applications can be built.  The framework includes methods for stream setup and teardown, channel encryption, authentication of a client to a server and of one server to another server, and primitives for push-style messages, publication of network availability information ("presence"), and request-response interactions.  This document also specifies the format for XMPP addresses, which are fully internationalizable.  This document obsoletes RFC 3920.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-saintandre-rfc3920bis-08' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-saintandre-rfc3920bis-08.txt' />
</reference>

<reference anchor='TLS'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'>
<organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2008' month='August' />
<abstract>
<t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5246' />
<format type='TXT' octets='222395' target='ftp://ftp.isi.edu/in-notes/rfc5246.txt' />
</reference>

<reference anchor="XEP-0047">
  <front>
    <title>In-Band Bytestreams (IBB)</title>
    <author initials="J." surname="Karneges" fullname="Justin Karneges">
      <organization/>
      <address>
        <email>justin@affinix.com</email>
      </address>
    </author>
    <date day="21" month="November" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0047"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0047.html"/>
</reference>
<reference anchor="XEP-0166">
  <front>
    <title>Jingle</title>
    <author initials="S." surname="Ludwig" fullname="Scott Ludwig">
      <organization/>
      <address>
        <email>scottlu@google.com</email>
      </address>
    </author>
    <author initials="J." surname="Beda" fullname="Joe Beda">
      <organization/>
      <address>
        <email>jbeda@google.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="R." surname="McQueen" fullname="Robert McQueen">
      <organization/>
      <address>
        <email>robert.mcqueen@collabora.co.uk</email>
      </address>
    </author>
    <author initials="S." surname="Egan" fullname="Sean Egan">
      <organization/>
      <address>
        <email>seanegan@google.com</email>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <date day="18" month="December" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0166"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0166.html"/>
</reference>

<reference anchor="XEP-0210">
  <front>
    <title>Requirements for Encrypted Sessions</title>
    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <date day="30" month="May" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0210"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0210.html"/>
</reference>

<reference anchor="XEP-0247">
  <front>
    <title>Jingle XML Streams</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="J." surname="Karneges" fullname="Justin Karneges">
      <organization/>
      <address>
        <email>justin@affinix.com</email>
      </address>
    </author>
    <author initials="D." surname="Meyer" fullname="Dirk Meyer">
      <organization/>
      <address>
        <email>dmeyer@tzi.de</email>
      </address>
    </author>
    <date day="18" month="June" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0247"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0247.html"/>
</reference>

    </references>

    <references title="Informative References">

<reference anchor='DTLS'>
<front>
<title>Datagram Transport Layer Security</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<author initials='N.' surname='Modadugu' fullname='N. Modadugu'>
<organization /></author>
<date year='2006' month='April' />
<abstract>
<t>This document specifies Version 1.0 of the Datagram Transport Layer Security (DTLS) protocol.  The DTLS protocol provides communications privacy for datagram protocols.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees.  Datagram semantics of the underlying transport are preserved by the DTLS protocol. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='4347' />
<format type='TXT' octets='56014' target='ftp://ftp.isi.edu/in-notes/rfc4347.txt' />
</reference>

<reference anchor='DTLS-SRTP'>
<front>
<title>Datagram Transport Layer Security (DTLS) Extension to Establish Keys for  Secure Real-time Transport Protocol (SRTP)</title>
<author initials='D' surname='McGrew' fullname='David McGrew'>
    <organization />
</author>
<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>
<date month='October' day='29' year='2008' />
<abstract><t>This document describes a Datagram Transport Layer Security (DTLS) extension to establish keys for secure RTP (SRTP) and secure RTP Control Protocol (SRTCP) flows.  DTLS keying happens on the media path, independent of any out-of-band signalling channel present.</t></abstract>
</front>
<seriesInfo name='Internet-Draft' value='draft-ietf-avt-dtls-srtp-06' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-avt-dtls-srtp-06.txt' />
</reference>

<reference anchor='HTTP-TLS'>
<front>
<title>HTTP Over TLS</title>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization /></author>
<date year='2000' month='May' />
<abstract>
<t>This memo describes how to use Transport Layer Security (TLS) to secure Hypertext Transfer Protocol (HTTP) connections over the Internet.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='2818' />
<format type='TXT' octets='15170' target='ftp://ftp.isi.edu/in-notes/rfc2818.txt' />
</reference>

<reference anchor='RFC3923'>
<front>
<title abbrev='XMPP E2E'>End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP)</title>
<author initials='P.' surname='Saint-Andre' fullname='Peter Saint-Andre'>
<organization>Jabber Software Foundation</organization>
<address>
<email>stpeter@jabber.org</email></address></author>
<date year='2004' month='October' />
<area>Applications</area>
<workgroup>XMPP Working Group</workgroup>
<keyword>RFC</keyword>
<keyword>Request for Comments</keyword>
<keyword>I-D</keyword>
<keyword>Internet-Draft</keyword>
<keyword>XMPP</keyword>
<keyword>Extensible Messaging and Presence Protocol</keyword>
<keyword>Jabber</keyword>
<keyword>IM</keyword>
<keyword>Instant Messaging</keyword>
<keyword>Presence</keyword>
<keyword>XML</keyword>
<keyword>Extensible Markup Language</keyword>
<abstract>
<t>This memo defines methods of end-to-end signing and object encryption for the Extensible Messaging and Presence Protocol (XMPP).</t></abstract></front>
<seriesInfo name='RFC' value='3923' />
<format type='TXT' octets='51828' target='ftp://ftp.isi.edu/in-notes/rfc3923.txt' />
<format type='HTML' octets='77480' target='http://xml.resource.org/public/rfc/html/rfc3923.html' />
<format type='XML' octets='71879' target='http://xml.resource.org/public/rfc/xml/rfc3923.xml' />
</reference>

<reference anchor='RFC5056'>
<front>
<title>On the Use of Channel Bindings to Secure Channels</title>
<author initials='N.' surname='Williams' fullname='N. Williams'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>The concept of channel binding allows applications to establish that the two end-points of a secure channel at one network layer are the same as at a higher layer by binding authentication at the higher layer to the channel at the lower layer. This allows applications to delegate session protection to lower layers, which has various performance benefits.&lt;/t>&lt;t> This document discusses and formalizes the concept of channel binding to secure channels. [STANDARDS TRACK]</t></abstract></front>
<seriesInfo name='RFC' value='5056' />
<format type='TXT' octets='49995' target='ftp://ftp.isi.edu/in-notes/rfc5056.txt' />
</reference>

<reference anchor='RFC5081'>
<front>
<title>Using OpenPGP Keys for Transport Layer Security (TLS) Authentication</title>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This memo proposes extensions to the Transport Layer Security (TLS) protocol to support the OpenPGP key format.  The extensions discussed here include a certificate type negotiation mechanism, and the required modifications to the TLS Handshake Protocol.  This memo defines an Experimental Protocol for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='5081' />
<format type='TXT' octets='15300' target='ftp://ftp.isi.edu/in-notes/rfc5081.txt' />
</reference>

<reference anchor='SRP'>
<front>
<title>Using the Secure Remote Password (SRP) Protocol for TLS Authentication</title>
<author initials='D.' surname='Taylor' fullname='D. Taylor'>
<organization /></author>
<author initials='T.' surname='Wu' fullname='T. Wu'>
<organization /></author>
<author initials='N.' surname='Mavrogiannopoulos' fullname='N. Mavrogiannopoulos'>
<organization /></author>
<author initials='T.' surname='Perrin' fullname='T. Perrin'>
<organization /></author>
<date year='2007' month='November' />
<abstract>
<t>This memo presents a technique for using the Secure Remote Password protocol as an authentication method for the Transport Layer Security protocol.  This memo provides information for the Internet community.</t></abstract></front>
<seriesInfo name='RFC' value='5054' />
<format type='TXT' octets='44445' target='ftp://ftp.isi.edu/in-notes/rfc5054.txt' />
</reference>

<reference anchor="XEP-0027">
  <front>
    <title>Current Jabber OpenPGP Usage</title>
    <author initials="T." surname="Muldowney" fullname="Thomas Muldowney">
      <organization/>
      <address>
        <email>temas@jabber.org</email>
      </address>
    </author>
    <date day="29" month="November" year="2006"/>
  </front>
  <seriesInfo name="XSF XEP" value="0027"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0027.html"/>
</reference>

<reference anchor="XEP-0030">
  <front>
    <title>Service Discovery</title>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <author initials="P." surname="Millard" fullname="Peter Millard">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="R." surname="Eatmon" fullname="Ryan Eatmon">
      <organization/>
      <address>
        <email>reatmon@jabber.org</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="06" month="June" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0030"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0030.html"/>
</reference>

<reference anchor="XEP-0045">
  <front>
    <title>Multi-User Chat</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="16" month="July" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0045"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0045.html"/>
</reference>

<reference anchor="XEP-0115">
  <front>
    <title>Entity Capabilities</title>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="R." surname="Tron&#xE7;on" fullname="Remko Tron&#xE7;on">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="J." surname="Konieczny" fullname="Jacek Konieczny">
      <organization/>
      <address>
        <email>jajcus@jajcus.net</email>
      </address>
    </author>
    <date day="26" month="February" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0115"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0115.html"/>
</reference>

<reference anchor="XEP-0167">
  <front>
    <title>Jingle RTP Sessions</title>
    <author initials="S." surname="Ludwig" fullname="Scott Ludwig">
      <organization/>
      <address>
        <email>scottlu@google.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="S." surname="Egan" fullname="Sean Egan">
      <organization/>
      <address>
        <email>seanegan@google.com</email>
      </address>
    </author>
    <author initials="R." surname="McQueen" fullname="Robert McQueen">
      <organization/>
      <address>
        <email>robert.mcqueen@collabora.co.uk</email>
      </address>
    </author>
    <author initials="D." surname="Cionoiu" fullname="Diana Cionoiu">
      <organization/>
      <address>
        <email>diana@null.ro</email>
      </address>
    </author>
    <date day="19" month="December" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0167"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0167.html"/>
</reference>

<reference anchor="XEP-0176">
  <front>
    <title>Jingle ICE-UDP Transport Method</title>
    <author initials="J." surname="Beda" fullname="Joe Beda">
      <organization/>
      <address>
        <email>jbeda@google.com</email>
      </address>
    </author>
    <author initials="S." surname="Ludwig" fullname="Scott Ludwig">
      <organization/>
      <address>
        <email>scottlu@google.com</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization/>
      <address>
        <email>jhildebrand@jabber.com</email>
      </address>
    </author>
    <author initials="S." surname="Egan" fullname="Sean Egan">
      <organization/>
      <address>
        <email>seanegan@google.com</email>
      </address>
    </author>
    <author initials="R." surname="McQueen" fullname="Robert McQueen">
      <organization/>
      <address>
        <email>robert.mcqueen@collabora.co.uk</email>
      </address>
    </author>
    <date day="17" month="February" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0176"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0176.html"/>
</reference>

<reference anchor="XEP-0189">
  <front>
    <title>Public Key Publishing</title>
    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="D." surname="Meyer" fullname="Dirk Meyer">
      <organization/>
      <address>
        <email>dmeyer@tzi.de</email>
      </address>
    </author>
    <date day="08" month="September" year="2008"/>
  </front>
  <seriesInfo name="XSF XEP" value="0189"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0189.html"/>
</reference>

<reference anchor="XEP-0218">
  <front>
    <title>Bootstrapping Implementation of Encrypted Sessions</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="I." surname="Paterson" fullname="Ian Paterson">
      <organization/>
      <address>
        <email>ian.paterson@clientside.co.uk</email>
      </address>
    </author>
    <date day="30" month="May" year="2007"/>
  </front>
  <seriesInfo name="XSF XEP" value="0218"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0218.html"/>
</reference>

<reference anchor="XEP-0234">
  <front>
    <title>Jingle File Transfer</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="19" month="February" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0234"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0234.html"/>
</reference>

<reference anchor="XEP-0260">
  <front>
    <title>Jingle SOCKS5 Bytestreams Transport Method</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <author initials="D." surname="Meyer" fullname="Dirk Meyer">
      <organization/>
      <address>
        <email>dmeyer@tzi.de</email>
      </address>
    </author>
    <date day="19" month="February" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0260"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0260.html"/>
</reference>

<reference anchor="XEP-0261">
  <front>
    <title>Jingle In-Band Bytestreams Transport</title>
    <author initials="P." surname="Saint-Andre" fullname="Peter Saint-Andre">
      <organization/>
      <address>
        <email/>
      </address>
    </author>
    <date day="19" month="February" year="2009"/>
  </front>
  <seriesInfo name="XSF XEP" value="0261"/>
  <format type="HTML" target="http://www.xmpp.org/extensions/xep-0261.html"/>
</reference>

    </references>

    <section title='XML Schema' anchor='schema'>
      <t>The XML schema will be provided in a later version of this document.</t>
    </section>

    <section title="Copying Conditions" anchor="copying">
      <t>Regarding this entire document or any portion of it, the authors make no guarantees and are not responsible for any damage resulting from its use.  The authors grant irrevocable permission to anyone to use, modify, and distribute it in any way that does not diminish the rights of anyone else to use, modify, and distribute it, provided that redistributed derivative works do not contain misleading author or version information.  Derivative works need not be licensed under similar terms.</t>
    </section>

  </back>
</rfc>
